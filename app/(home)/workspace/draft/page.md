# 草稿

## 知识点回顾

### es6

- let/const
- ()=>{}
- ``
- const { name, age } = person;
- {...} [...]
- 默认参数
- promise/async/await
- Class
- import/export esm
- Map Set
- ?.
- 空置 ??
- 函数参数结构
- 对象字面量增强 键值对相同
- 迭代器和生成器
- Proxy 和 Reflect
- Array find, findIndex, includes
- Object.entries(), Object.values(), Object.fromEntries()
- BigInt

### css

BFC，即块级格式上下文（Block Formatting Context）

BFC 的主要作用和特性包括

- 外边距折叠的阻止： BFC 可以阻止相邻块级元素之间的外边距重叠问题，这有助于更准确地控制元素之间的间距。
- 父子元素的外边距隔离： 在 BFC 中，父元素和其第一个/最后一个子元素之间的外边距不会重叠，避免了布局塌陷问题。
- 清除浮动： BFC 可以通过浮动元素内部创建一个新的格式上下文，从而清除浮动，防止父元素塌陷。
- 定位与布局： BFC 影响元素的定位和布局方式，使得元素在 BFC 内部遵循一些特定的规则，例如浮动元素不会覆盖 BFC 内部的非浮动元素。
- 自适应宽度： BFC 会自动计算浮动元素的宽度，从而使其适应容器宽度。
- 环境隔离： BFC 内部的元素和外部的元素相互隔离，不会受到外部环境的影响。

物理像素（Physical Pixel）

物理像素是显示器或屏幕上的最小可见单位，通常由一个发光的点或一个子像素组成。
物理像素决定了屏幕的分辨率，即屏幕上可以显示多少个物理像素。
不同设备的物理像素可能大小不同，例如高分辨率屏幕的物理像素可能更小。

逻辑像素（CSS Pixel / Device-Independent Pixel）

逻辑像素是在 CSS 和 Web 开发中使用的虚拟单位，用于定义元素的尺寸和布局。
逻辑像素是抽象概念，不与实际的物理像素一一对应，而是被映射到物理像素上。
在标准情况下，一个逻辑像素会映射到一个物理像素，但在高分辨率设备上，可能会映射到多个物理像素，从而提供更高的清晰度。

像素密度（Pixel Density）

像素密度是指在给定区域内物理像素的数量。通常以“每英寸像素数”（PPI）表示。
高像素密度意味着在同样的物理尺寸内有更多的像素，从而提供更高的分辨率和图像质量。
一般来说，高分辨率设备拥有更高的像素密度，例如高清电视、智能手机、平板电脑等。

逻辑像素和像素密度之间的关系：在高分辨率设备上，一个逻辑像素可能映射到多个物理像素，这就是所谓的“像素密度倍增”。这意味着开发人员可以使用相同的逻辑像素单位来处理不同像素密度的设备，从而实现统一的界面和用户体验。

### vue 路由

```ts
router.beforeEach((to, from, next) => {
  // ...
  // 返回 false 以取消导航
  return false
})
```

### vuex

- store
- getters
- mutations
- actions

### axios

interceptors

### 用户授权和用户鉴权

| 项目     | 用户鉴权（Authentication） | 用户授权（Authorization） |
|----------|-----------------------------|----------------------------|
| 是什么   | 判断“你是谁”               | 判断“你能做什么”         |
| 目的     | 验证身份是否合法           | 判断权限是否足够         |
| 举例     | 登录账号、验证密码或 token | 判断是否能访问某个页面、操作某功能 |
| 常见方式 | 密码登录、验证码登录、OAuth | 权限系统、角色系统（RBAC） |
| 发生时机 | 登录时                      | 登录后，每次操作

### 简述vue3的 Setup/Composition API

Vue 3 引入了 Composition API，并通过 setup() 函数让开发者可以在一个地方组织逻辑，而不再依赖 Vue 2 中的选项式 API（如 data, methods, computed 等）。Composition API 更加灵活、模块化，方便处理复杂的逻辑和重用代码。

### react router

react-router有几种路由模式？

- `<BrowserRouter/>`：浏览器模式，基于HTML5的historyAPI实现
- `<HashRouter/>:` 有#号，（刷新网页能找到对应路径，但会丢失状态）
- `<MemoryRouter/>`：路由保存在内存中，不能前进后退（因为地址栏没变化）
- `<NativRouter/>`：移动端使用，配合ReactNative原生使用
- `<StaticRouter/>`: 静态路由，需要如后台服务器配合设置

### redux
使用 Redux 的优点：
- 单一数据源：Redux 提供了单一的 Store 来管理整个应用的状态，使得状态管理变得更加统一和可控。
- 可预测性：由于 Redux 遵循严格的数据流规则，状态的变化变得可预测，容易追踪和调试。
- 可插拔的中间件：Redux 支持中间件机制，可以方便地添加各种功能，例如异步操作、日志记录、时间旅行等。
- 易于测试：由于 Redux 中的数据和逻辑都是纯函数，因此可以更容易地进行单元测试和集成测试。
- 组件解耦：通过 connect 函数将组件与 Redux Store 连接，可以将状态管理逻辑与组件逻辑分离，提高了组件的复用性和可维护性。

使用 Redux 的缺点：
- 学习曲线：Redux 有一定的学习曲线，特别是对于初学者来说，理解 Redux 的概念和使用方式可能需要一定的时间和精力。
- 繁琐的模板代码：Redux 在实现上需要编写大量的模板代码，例如定义 action 类型、编写 action 创建函数、编写 reducer 等，这可能会增加代码量和复杂度。
- 过度使用：有时候为了状态管理而引入 Redux 可能会显得过度，特别是对于较小规模的应用或简单的组件来说，使用 Redux 可能会增加不必要的复杂性。

redux具体是怎么做到精准更新的

Redux 之所以能够实现精准更新，主要是因为它遵循了以下几个核心原则和机制：

- 单一数据源：
Redux 应用的整个状态被存储在单一的数据源中，称为 Store。这使得状态的变化变得可预测和可追踪，因为所有的状态变化都发生在同一个地方。

状态不可变性：
- Redux 要求状态是不可变的。也就是说，一旦状态被创建，它就不能直接被修改，只能通过触发一个 action 来描述状态的变化。这样可以确保每次状态变化都产生一个全新的状态对象，从而更容易进行精准更新。

- 纯函数的 reducer：
在 Redux 中，reducer 是一个纯函数，它接收先前的状态和一个 action，并返回一个新的状态。由于 reducer 是纯函数，它不会修改原始的状态，而是创建一个新的状态对象。这确保了状态更新的纯粹性和可预测性。

- 浅比较：
Redux 使用浅比较来判断状态是否发生了变化。当 dispatch 一个 action 后，Redux 会先调用 reducer 来计算新的状态，然后将新的状态与旧的状态进行浅比较。只有当新旧状态对象的引用发生变化时，Redux 才认为状态发生了变化，从而触发更新。

- 组件连接：
Redux 提供了 connect 函数来连接 React 组件和 Redux Store。通过 connect 函数，React 组件可以订阅 Redux Store 中的状态，并在状态发生变化时进行重新渲染。由于 React 的 Virtual DOM 机制，只有发生实际变化的部分才会被重新渲染，从而实现了精准更新。

### 微信小程序开发流程
环境搭建
开发代码
调试与预览
上传与发布
后期维护

### uni-app  #ifdef 或 #ifndef  #endif

### vite
如何指定 vite 插件 的执行顺序？

可以使用 enforce 修饰符来强制插件的位置:

pre：在 Vite 核心插件之前调用该插件
默认：在 Vite 核心插件之后调用该插件
post：在 Vite 构建插件之后调用该插件

为什么说 vite 比 webpack 要快

和 webpack 对比，为什么 vite 的冷启动、热启动、热更新都会快？这就要说说二者的区别。
使用 webpack 时，从 yarn start 命令启动，到最后页面展示，需要经历的过程：

以 entry 配置项为起点，做一个全量的打包，并生成一个入口文件 index.html 文件；
启动一个 node 服务；
打开浏览器，去访问入 index.html，然后去加载已经打包好的 js、css 文件；

在整个工作过程中，最重要的就是第一步中的全量打包，中间涉及到构建 module graph (涉及到大量度文件操作、文件内容解析、文件内容转换)、chunk 构建，这个需要消耗大量的时间。尽管在二次启动、热更新过程中，在构建 module graph 中可以充分利用缓存，但随着项目的规模越来越大，整个开发体验也越来越差。

使用 esbuild 预构建依赖，提前将项目的第三方依赖格式化为 ESM 模块；

启动一个 node 服务；
打开浏览器，去访问 index.html；
基于浏览器已经支持原生的 ESM 模块, 逐步去加载入口文件以及入口文件的依赖模块。浏览器发起请求以后，dev server端会通过middlewares对请求做拦截，然后对源文件做resolve、load、transform、parse操作，然后再将转换以后的内容发送给浏览器。

webpack

请说说常见的loader

sass-loader：将SCSS/SASS代码转换成CSS
postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀，加上兼容的浏览器厂商前缀
css-loader：处理样式之间互相引用的逻辑, 加载 CSS，支持模块化、压缩、文件导入等特性
style-loader：将 css-loader 解析后的内容挂载到 html 页面当中
file-loader：可以指定要复制和放置资源文件的位置，以及使用版本哈希命名以获得更好的缓存，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)。
url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码，减少HTTP请求
image-loader：加载并且压缩图片文件
source-map-loader：加载额外的 Source Map 文件，以方便断点调试

Loader 本质就是一个函数。对函数中接收到的内容进行转换，返回转换后的结果。Loader 的作用是让 webpack 拥有加载和解析非 JavaScript 文件的能力！ 因为 Webpack 只认识 JavaScript，所以需要对其他类型的资源进行转译的预处理工作。Loader 可以理解为「翻译官」。比如常见的 json-loader, ts-loader等。

Plugin 就是插件，插件可以扩展 Webpack 的功能，让 Webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

### js

JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。
其中 Symbol 和 BigInt 是ES6 中新增的数据类型：

Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。
BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。

栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt）
堆：引用数据类型（对象、数组和函数）

- typeof 其中数组、对象、null都会被判断为object，其他判断都正确。
- instanceof 其内部运行机制是判断在其原型链中能否找到该类型的原型
- isArrray instanceof Array / obj.__proto__ === Array.prototype

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

箭头函数与普通函数有什么区别
（1）箭头函数比普通函数更加简洁
（2）箭头函数没有自己的this
箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。
（3）箭头函数不能作为构造函数使用

ES6 Module和CommonJS模块的区别：

CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；
import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。

ES6 Module和CommonJS模块的共同点：

CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。

for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下

forEach()否数组方法，值是基本类型, 改变不了;如果是引用类型分两种情况：
1、没有修改形参元素的地址值, 只是修改形参元素内部的某些属性，会改变原数组；
2、直接修改整个元素对象时，无法改变原数组，没有返回值map()否数组方法，不改变原数组，有返回值，可链式调用filter()否数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用for...of否for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环every() 和 some()否数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.find() 和 findIndex()否数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值reduce() 和 reduceRight()否数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作

 对原型、原型链的理解

在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。

防抖和节流的作用：

都是在高频事件中防止函数被多次调用，是一种性能优化的方案。
区别在于：

防抖函数只会在高频事件结束后 n 毫秒调用一次函数
节流函数会在高频事件触发过程当中每隔 n 毫秒调用一次函数。

闭包是JavaScript中一个非常重要的概念，它指的是一个函数能够访问并记住其词法作用域外的变量，即使该函数在其定义的作用域之外被执行。
更简单地说，闭包就是函数和它能够访问的变量的组合。
闭包的核心特性：

函数嵌套：当你在一个函数内部定义另一个函数时，内部函数可以访问外部函数的变量。
持久的词法作用域引用：内部函数会"记住"它被创建时的环境，即使外部函数已经执行完毕。
私有数据：闭包可以用来创建私有变量和方法，实现数据封装。

闭包常见应用场景：

实现私有变量和方法
创建函数工厂
实现模块模式
处理回调函数
事件处理器

TCP三次握手简述：

客户端发送SYN: "我想连接你，我的序列号是X"
服务器回复SYN+ACK: "我收到了，我的序列号是Y，你的序列号X+1"
客户端发送ACK: "我确认收到了，你的序列号Y+1"
